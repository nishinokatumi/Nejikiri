#pragma once
#include "SceneBase.h"
#include "GameSource/GameManager.h"

#define ED_BACK_MAX_Y	420									//	エンディング演出のマックス量Y
#define ED_CHANGE_Y		1									//	エンディング演出の変化量Y
#define ED_BACK_MAX_X	164									//	エンディング演出のマックス量X
#define ED_CHANGE_X		1									//	エンディング演出の変化量X
#define ED_SIZE			1200								//	エンディングのタイミングサイズ
#define BACK_GRAPH_SIZE_X	640									//	背景画像サイズ横
#define BACK_GRAPH_SIZE_Y	480									//	背景画像サイズ縦
#define BACK_GRAPH_TRANS	640									//	背景画像の交代位置
#define ED_MAP_MOVE		(ED_BACK_MAX_X/2)					//	エンディングのMAP動き


/*
ゲームのエンディング画面クラス
	エンディングアニメーション
*/
class SceneED : public SceneBase
{
private:
	//	動く位置(線形補間でアニメーション再現)
	struct MovePos
	{
		int X = 0;											//	Xの位置
		int Y = 0;											//	Yの位置
	};

	//	変数
	SceneBase* pNextSceneSave = this;						//	次のシーン保存用
	int EDTime = 0;											//	エンディングタイミング
	MovePos BackPos1 = { 0,0 };								//	背景の位置1枚目
	MovePos BackPos2 = { 0,0 };								//	背景の位置2枚目
	MovePos BackPos3 = { 0,0 };								//	背景の位置3枚目
	MovePos MapPos = { 0,0 };								//	MAPの位置の原点
	int BackConveQuaX1 = 0;									//	背景の位置の変化量X
	int BackConveQuaX2 = 0;									//	背景の位置の変化量X
	int BackConveQuaY = 0;									//	背景の位置の変化量Y
	int BackAngle = 2;										//	背景の角度
	int BackPosReverse = 1;									//	背景の位置を反転させる
	float EDWMRScale = 1.0f;								//	WMRの大きさ度合
	float EDWMRAlpha = 1.0f;								//	WMRの濃さ
	MovePos PLPos = { 0,0 };								//	プレイヤーの位置
	int PLGraph = 0;											//	プレイヤーの画像番号
	MovePos GameClearPos = { 0,0 };							//	文字の位置
	int ColorBase = 0;										//	色の設定基本(黒)
	int ColorMain = 0;										//	色の設定基本(白)
	int ColorSele = 0;										//	色の設定基本(黄)
	int MapNo = 1;											//	表示するステージナンバー
	MAP_INFO::Stage NowMapData[3] =							//	ステージのマップチップデータ(0:無 1:段差　2:1の上下反転)
	{
		{
			1,0,
		{
			2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,
			2,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
		}
		},
		{
			1,0,
		{
			2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
		}
		},
		{
			1,0,
		{
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,2,
			2,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,2,
			2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,
		}
		},
	};


public:
	SceneED();												//	初期設定

	//	ゲームエンディングの処理
	void Initia();											//	初期処理
	void Final();											//	最終処理
	SceneBase* Update();									//	更新処理
	void BaseUpdate();										//	更新処理の内容
	void Draw();											//	表示処理
	void DrawMap(int MapPosX, int MapPosY, int MapNum);		//	マップの表示処理

	//	最初の位置と最後の位置,現在時間 線形補間
	void KeyFrame(MovePos First, MovePos End, MovePos* pNow, int FirstTime, int EndTime)
	{
		float NowTime =										//	線形補間内の今の時間を現在と最初と最後の時間から計算する
			(float)(EDTime - FirstTime) / (float)(EndTime - FirstTime);
		float Time = NowTime * NowTime *(3 - 2 * NowTime);	//	時間の割合	終始ゆっくり中盤早く

		//	今の時間がおおよそ0よりも下だった場合
		if (NowTime <= 0.000000001f)
		{
			Time = 0.0f;									//	今の時間を0に
		}
		//	今の時間がおおよそ1よりも上だった場合
		else if (NowTime - 1.0f > 0.00000001f)
		{
			Time = 1.0f;									//	今の時間を1に
		}
		pNow->X =
			(int)(First.X * (1.0f - Time) + End.X * Time);	//	時間の割合から計算
		pNow->Y =
			(int)(First.Y * (1.0f - Time) + End.Y * Time);	//	時間の割合から計算
	}

	//	最初の位置と最後の位置,現在時間 線形補間float
	void KeyFrameFloat(float First, float End, float* pNow, int FirstTime, int EndTime)
	{
		float NowTime =										//	線形補間内の今の時間を現在と最初と最後の時間から計算する
			(float)(EDTime - FirstTime) / (float)(EndTime - FirstTime);
		float Time = NowTime * NowTime *(3 - 2 * NowTime);	//	時間の割合	終始ゆっくり中盤早く

		//	今の時間がおおよそ0よりも下だった場合
		if (NowTime <= 0.000000001f)
		{
			Time = 0.0f;									//	今の時間を0に
		}
		//	今の時間がおおよそ1よりも上だった場合
		else if (NowTime - 1.0f > 0.00000001f)
		{
			Time = 1.0f;									//	今の時間を1に
		}
		*pNow = (First * (1.0f - Time) + End * Time);		//	時間の割合から計算
	}

};